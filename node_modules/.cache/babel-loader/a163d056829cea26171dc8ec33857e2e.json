{"ast":null,"code":"import _regeneratorRuntime from \"/home/sin/Udemy/blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/sin/Udemy/blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _ from 'lodash';\nimport jsonPlaceholder from '../apis/jsonPlaceholder'; // With Redux-Thunk + ES2015 \n\nexport var fetchPosts = function fetchPosts() {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(dispatch) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return jsonPlaceholder.get('./posts');\n\n              case 2:\n                response = _context.sent;\n                dispatch({\n                  type: 'FETCH_POST',\n                  payload: response.data\n                });\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n  );\n}; //3. another way to stop unnecessary fetching\n\nexport var fetchPostsAndUsers = function fetchPostsAndUsers() {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(dispatch) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                console.log('$$$About to fetch posts!');\n                _context2.next = 3;\n                return dispatch(fetchPosts());\n\n              case 3:\n                console.log('$$$fetched posts!');\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }()\n  );\n}; // export const fetchUser = (id) => async dispatch => {\n//     const response = await jsonPlaceholder.get(`/users/${id}`);\n//     dispatch({\n//         type: 'FETCH_USER',\n//         payload: response.data,\n//     })\n// }\n//TOTALLY FINE!\n\nexport var selectPost = function selectPost() {\n  return {\n    type: 'SELECT_POST'\n  };\n}; //____________________________________________________________________________________________\n//1. Before memoizing => unnecessary fetching happening \n// export const fetchUser = (id) => async dispatch => {\n//   const response = await jsonPlaceholder.get(`/users/${id}`);\n//   dispatch({\n//       type: 'FETCH_USER',\n//       payload: response.data,\n//   })\n// }\n//2. After memoizing => no unnecesarry fetching\n\nexport var fetchUser = function fetchUser(id) {\n  return function (dispatch) {\n    _fetchUser(id, dispatch);\n  };\n};\n\nvar _fetchUser = _.memoize(\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(id, dispatch) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return jsonPlaceholder.get(\"/users/\".concat(id));\n\n          case 2:\n            response = _context3.sent;\n            dispatch({\n              type: 'FETCH_USER',\n              payload: response.data\n            });\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this);\n  }));\n\n  return function (_x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}());\n\n_________________________________________________________________________________________; //________________________________________________________________________________________\n// Without Redux-Thunk  \n// export const fetchPosts = () => {\n//     // logic below is breaking a rule of redux : Actions must be plain objects\n//     //1. Action creators must return plain JS objects with a type property - we are not!\n//     //2. By the time our action gets to a reducer, we won't have fetched our data!  \n//     // async, await is the reason\n//     // Listen to lesson 160, 161 agian\n//     const promise = jsonPlaceholder.get('./posts');\n//       return {\n//           type: 'FETCH_POSTS',\n//           payload: promise\n//       };\n// };\n// With Redux-Thunk \n// export const fetchPosts = () => {\n//   return async dispatch => {\n//     const response = await jsonPlaceholder.get('./posts');\n//     dispatch({ \n//         type: 'FETCH_POST', \n//         payload: response,\n//     })\n//   }\n// };\n//_________________________________________________________________________________________","map":{"version":3,"sources":["/home/sin/Udemy/blog/src/actions/index.js"],"names":["_","jsonPlaceholder","fetchPosts","dispatch","get","response","type","payload","data","fetchPostsAndUsers","console","log","selectPost","fetchUser","id","_fetchUser","memoize","_________________________________________________________________________________________"],"mappings":";;AAAA,OAAOA,CAAP,MAAc,QAAd;AACA,OAAOC,eAAP,MAA4B,yBAA5B,C,CAGA;;AACA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAM,iBAAMC,QAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACPF,eAAe,CAACG,GAAhB,CAAoB,SAApB,CADO;;AAAA;AACxBC,gBAAAA,QADwB;AAE9BF,gBAAAA,QAAQ,CAAC;AACLG,kBAAAA,IAAI,EAAE,YADD;AAELC,kBAAAA,OAAO,EAAEF,QAAQ,CAACG;AAFb,iBAAD,CAAR;;AAF8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAN;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAnB,C,CAQP;;AACA,OAAO,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAM,kBAAMN,QAAN;AAAA;AAAA;AAAA;AAAA;AACpCO,gBAAAA,OAAO,CAACC,GAAR,CAAY,0BAAZ;AADoC;AAAA,uBAE9BR,QAAQ,CAACD,UAAU,EAAX,CAFsB;;AAAA;AAGpCQ,gBAAAA,OAAO,CAACC,GAAR,CAAY,mBAAZ;;AAHoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAN;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAA3B,C,CAQP;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,GAAM;AAC5B,SAAO;AACHN,IAAAA,IAAI,EAAE;AADH,GAAP;AAGH,CAJM,C,CAMP;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA,OAAO,IAAMO,SAAS,GAAG,SAAZA,SAAY,CAAAC,EAAE;AAAA,SAAI,UAAAX,QAAQ,EAAI;AACzCY,IAAAA,UAAU,CAACD,EAAD,EAAKX,QAAL,CAAV;AACD,GAF0B;AAAA,CAApB;;AAIP,IAAMY,UAAU,GAAGf,CAAC,CAACgB,OAAF;AAAA;AAAA;AAAA;AAAA;AAAA,2BAAU,kBAAOF,EAAP,EAAWX,QAAX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACFF,eAAe,CAACG,GAAhB,kBAA8BU,EAA9B,EADE;;AAAA;AACnBT,YAAAA,QADmB;AAGzBF,YAAAA,QAAQ,CAAC;AACLG,cAAAA,IAAI,EAAE,YADD;AAELC,cAAAA,OAAO,EAAEF,QAAQ,CAACG;AAFb,aAAD,CAAR;;AAHyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAV;;AAAA;AAAA;AAAA;AAAA,IAAnB;;AAQAS,yFAAyF,C,CAGzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import _ from 'lodash';\nimport jsonPlaceholder from '../apis/jsonPlaceholder';\n\n\n// With Redux-Thunk + ES2015 \nexport const fetchPosts = () => async dispatch => {\n  const response = await jsonPlaceholder.get('./posts');\n  dispatch({ \n      type: 'FETCH_POST', \n      payload: response.data,\n  });\n};\n\n//3. another way to stop unnecessary fetching\nexport const fetchPostsAndUsers = () => async dispatch => {\n    console.log('$$$About to fetch posts!')\n    await dispatch(fetchPosts());\n    console.log('$$$fetched posts!')\n\n    \n};\n\n// export const fetchUser = (id) => async dispatch => {\n//     const response = await jsonPlaceholder.get(`/users/${id}`);\n  \n//     dispatch({\n//         type: 'FETCH_USER',\n//         payload: response.data,\n//     })\n// }\n\n//TOTALLY FINE!\nexport const selectPost = () => {\n    return {\n        type: 'SELECT_POST'\n    }\n};\n\n//____________________________________________________________________________________________\n//1. Before memoizing => unnecessary fetching happening \n// export const fetchUser = (id) => async dispatch => {\n//   const response = await jsonPlaceholder.get(`/users/${id}`);\n\n//   dispatch({\n//       type: 'FETCH_USER',\n//       payload: response.data,\n//   })\n// }\n\n//2. After memoizing => no unnecesarry fetching\nexport const fetchUser = id => dispatch => {\n  _fetchUser(id, dispatch);    \n};\n\nconst _fetchUser = _.memoize(async (id, dispatch) => {\n    const response = await jsonPlaceholder.get(`/users/${id}`);\n      \n    dispatch({\n        type: 'FETCH_USER',\n        payload: response.data,\n    })\n});\n_________________________________________________________________________________________\n\n\n//________________________________________________________________________________________\n// Without Redux-Thunk  \n// export const fetchPosts = () => {\n//     // logic below is breaking a rule of redux : Actions must be plain objects\n//     //1. Action creators must return plain JS objects with a type property - we are not!\n//     //2. By the time our action gets to a reducer, we won't have fetched our data!  \n//     // async, await is the reason\n//     // Listen to lesson 160, 161 agian\n//     const promise = jsonPlaceholder.get('./posts');\n//       return {\n//           type: 'FETCH_POSTS',\n//           payload: promise\n//       };\n// };\n\n// With Redux-Thunk \n// export const fetchPosts = () => {\n  \n//   return async dispatch => {\n//     const response = await jsonPlaceholder.get('./posts');\n\n//     dispatch({ \n//         type: 'FETCH_POST', \n//         payload: response,\n//     })\n//   }\n// };\n//_________________________________________________________________________________________"]},"metadata":{},"sourceType":"module"}