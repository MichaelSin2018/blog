{"ast":null,"code":"import _regeneratorRuntime from \"/home/sin/Udemy/blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/sin/Udemy/blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _ from 'lodash';\nimport jsonPlaceholder from '../apis/jsonPlaceholder'; // With Redux-Thunk + ES2015 \n\nexport var fetchPosts = function fetchPosts() {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(dispatch) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return jsonPlaceholder.get('./posts');\n\n              case 2:\n                response = _context.sent;\n                dispatch({\n                  type: 'FETCH_POST',\n                  payload: response.data\n                });\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n  );\n}; //1. Before memoizing\n// export const fetchUser = (userId) => async dispatch => {\n//   const response = await jsonPlaceholder.get(`/users/${userId}`);\n//   dispatch({\n//       type: 'FETCH_USER',\n//       payload: response.data,\n//   })\n// }\n//2. After memoizing\n\nexport var fetchUser = function fetchUser(id) {\n  return function (dispatch) {\n    _fetchUser(id, dispatch);\n  };\n};\n\nvar _fetchUser = _.memoize(\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(id, dispatch) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return jsonPlaceholder.get(\"/users/\".concat(id));\n\n          case 2:\n            response = _context2.sent;\n            dispatch({\n              type: 'FETCH_USER',\n              payload: response.data\n            });\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n\n  return function (_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}()); //TOTALLY FINE!\n\n\nexport var selectPost = function selectPost() {\n  return {\n    type: 'SELECT_POST'\n  };\n}; // Without Redux-Thunk  \n// export const fetchPosts = () => {\n//     // logic below is breaking a rule of redux : Actions must be plain objects\n//     //1. Action creators must return plain JS objects with a type property - we are not!\n//     //2. By the time our action gets to a reducer, we won't have fetched our data!  \n//     // async, await is the reason\n//     // Listen to lesson 160, 161 agian\n//     const promise = jsonPlaceholder.get('./posts');\n//       return {\n//           type: 'FETCH_POSTS',\n//           payload: promise\n//       };\n// };\n// With Redux-Thunk \n// export const fetchPosts = () => {\n//   return async dispatch => {\n//     const response = await jsonPlaceholder.get('./posts');\n//     dispatch({ \n//         type: 'FETCH_POST', \n//         payload: response,\n//     })\n//   }\n// };","map":{"version":3,"sources":["/home/sin/Udemy/blog/src/actions/index.js"],"names":["_","jsonPlaceholder","fetchPosts","dispatch","get","response","type","payload","data","fetchUser","id","_fetchUser","memoize","selectPost"],"mappings":";;AAAA,OAAOA,CAAP,MAAc,QAAd;AACA,OAAOC,eAAP,MAA4B,yBAA5B,C,CAEA;;AACA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAM,iBAAMC,QAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACPF,eAAe,CAACG,GAAhB,CAAoB,SAApB,CADO;;AAAA;AACxBC,gBAAAA,QADwB;AAE9BF,gBAAAA,QAAQ,CAAC;AACLG,kBAAAA,IAAI,EAAE,YADD;AAELC,kBAAAA,OAAO,EAAEF,QAAQ,CAACG;AAFb,iBAAD,CAAR;;AAF8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAN;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAnB,C,CAQP;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAAAC,EAAE;AAAA,SAAI,UAAAP,QAAQ,EAAI;AACzCQ,IAAAA,UAAU,CAACD,EAAD,EAAKP,QAAL,CAAV;AACD,GAF0B;AAAA,CAApB;;AAIP,IAAMQ,UAAU,GAAGX,CAAC,CAACY,OAAF;AAAA;AAAA;AAAA;AAAA;AAAA,2BAAU,kBAAOF,EAAP,EAAWP,QAAX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACFF,eAAe,CAACG,GAAhB,kBAA8BM,EAA9B,EADE;;AAAA;AACnBL,YAAAA,QADmB;AAGzBF,YAAAA,QAAQ,CAAC;AACLG,cAAAA,IAAI,EAAE,YADD;AAELC,cAAAA,OAAO,EAAEF,QAAQ,CAACG;AAFb,aAAD,CAAR;;AAHyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAV;;AAAA;AAAA;AAAA;AAAA,IAAnB,C,CAWA;;;AACA,OAAO,IAAMK,UAAU,GAAG,SAAbA,UAAa,GAAM;AAC5B,SAAO;AACHP,IAAAA,IAAI,EAAE;AADH,GAAP;AAGH,CAJM,C,CAOP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import _ from 'lodash';\nimport jsonPlaceholder from '../apis/jsonPlaceholder';\n\n// With Redux-Thunk + ES2015 \nexport const fetchPosts = () => async dispatch => {\n  const response = await jsonPlaceholder.get('./posts');\n  dispatch({ \n      type: 'FETCH_POST', \n      payload: response.data,\n  });\n};\n\n//1. Before memoizing\n// export const fetchUser = (userId) => async dispatch => {\n//   const response = await jsonPlaceholder.get(`/users/${userId}`);\n\n//   dispatch({\n//       type: 'FETCH_USER',\n//       payload: response.data,\n//   })\n// }\n\n//2. After memoizing\nexport const fetchUser = id => dispatch => {\n  _fetchUser(id, dispatch);    \n};\n\nconst _fetchUser = _.memoize(async (id, dispatch) => {\n    const response = await jsonPlaceholder.get(`/users/${id}`);\n      \n    dispatch({\n        type: 'FETCH_USER',\n        payload: response.data,\n    })\n});\n    \n    \n\n//TOTALLY FINE!\nexport const selectPost = () => {\n    return {\n        type: 'SELECT_POST'\n    }\n};\n\n\n// Without Redux-Thunk  \n// export const fetchPosts = () => {\n//     // logic below is breaking a rule of redux : Actions must be plain objects\n//     //1. Action creators must return plain JS objects with a type property - we are not!\n//     //2. By the time our action gets to a reducer, we won't have fetched our data!  \n//     // async, await is the reason\n//     // Listen to lesson 160, 161 agian\n//     const promise = jsonPlaceholder.get('./posts');\n//       return {\n//           type: 'FETCH_POSTS',\n//           payload: promise\n//       };\n// };\n\n// With Redux-Thunk \n// export const fetchPosts = () => {\n  \n//   return async dispatch => {\n//     const response = await jsonPlaceholder.get('./posts');\n\n//     dispatch({ \n//         type: 'FETCH_POST', \n//         payload: response,\n//     })\n//   }\n// };"]},"metadata":{},"sourceType":"module"}